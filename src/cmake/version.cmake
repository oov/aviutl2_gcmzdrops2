if(NOT DEFINED local_dir OR NOT DEFINED input_file OR NOT DEFINED output_file)
  message(FATAL_ERROR "Required variables not defined: local_dir, input_file, output_file")
endif()

# Find Git executable
find_program(GIT_EXECUTABLE git)
if(NOT GIT_EXECUTABLE)
  message(WARNING "Git not found, using default version info")
  set(GIT_TAG "v0.0.0")
  set(GIT_REVISION "unknown")
  set(GIT_BRANCH "unknown")
else()
  # Get current tag if HEAD points to a tagged commit
  execute_process(
    COMMAND ${GIT_EXECUTABLE} tag --points-at HEAD
    WORKING_DIRECTORY "${local_dir}"
    OUTPUT_VARIABLE GIT_TAG
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if("${GIT_TAG}" STREQUAL "")
    # If no tag, get the most recent tag and add suffix
    execute_process(
      COMMAND ${GIT_EXECUTABLE} describe --tags --abbrev=0
      WORKING_DIRECTORY "${local_dir}"
      OUTPUT_VARIABLE GIT_LATEST_TAG
      ERROR_QUIET
      OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    if("${GIT_LATEST_TAG}" STREQUAL "")
      set(GIT_TAG "v0.0.0-dev")
    else()
      set(GIT_TAG "${GIT_LATEST_TAG}-dev")
    endif()
  endif()

  # Get short commit hash
  execute_process(
    COMMAND ${GIT_EXECUTABLE} rev-parse --short HEAD
    WORKING_DIRECTORY "${local_dir}"
    OUTPUT_VARIABLE GIT_REVISION
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if("${GIT_REVISION}" STREQUAL "")
    set(GIT_REVISION "unknown")
  endif()

  # Get current branch name
  execute_process(
    COMMAND ${GIT_EXECUTABLE} rev-parse --abbrev-ref HEAD
    WORKING_DIRECTORY "${local_dir}"
    OUTPUT_VARIABLE GIT_BRANCH
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if("${GIT_BRANCH}" STREQUAL "")
    set(GIT_BRANCH "unknown")
  endif()
endif()

# Set variables for template (matching existing version.h.in format)
set(_git_tag "${GIT_TAG}")
set(_git_revision "${GIT_REVISION}")

# Parse version for uint32
set(_tag_for_parsing "${GIT_TAG}")
set(_is_dev FALSE)
if(_tag_for_parsing MATCHES "-dev$")
  string(REGEX REPLACE "-dev$" "" _tag_for_parsing "${_tag_for_parsing}")
  set(_is_dev TRUE)
endif()

string(REGEX MATCH "^v([0-9]+)\\.([0-9]+)\\.([0-9]+)(.*)$" _match "${_tag_for_parsing}")

if(_match)
  set(_major ${CMAKE_MATCH_1})
  set(_minor ${CMAKE_MATCH_2})
  set(_patch ${CMAKE_MATCH_3})
  set(_suffix "${CMAKE_MATCH_4}")

  # Remove leading hyphen from suffix if present
  if(_suffix MATCHES "^-")
    string(REGEX REPLACE "^-" "" _suffix "${_suffix}")
  endif()

  if(_major GREATER 127)
    message(FATAL_ERROR "Major version ${_major} exceeds limit 127")
  endif()
  if(_minor GREATER 255)
    message(FATAL_ERROR "Minor version ${_minor} exceeds limit 255")
  endif()
  if(_patch GREATER 255)
    message(FATAL_ERROR "Patch version ${_patch} exceeds limit 255")
  endif()

  set(_stage 511) # Default to stable

  if("${_suffix}" STREQUAL "")
    if(_is_dev)
      set(_stage 0) # Treat -dev as alpha0
    else()
      # Stable
    endif()
  elseif(_suffix MATCHES "^alpha([0-9]+)$")
    set(_n ${CMAKE_MATCH_1})
    if(_n GREATER 169)
      message(FATAL_ERROR "Alpha version ${_n} exceeds limit 169")
    endif()
    math(EXPR _stage "0 + ${_n}")
  elseif(_suffix MATCHES "^beta([0-9]+)$")
    set(_n ${CMAKE_MATCH_1})
    if(_n GREATER 169)
      message(FATAL_ERROR "Beta version ${_n} exceeds limit 169")
    endif()
    math(EXPR _stage "170 + ${_n}")
  elseif(_suffix MATCHES "^rc([0-9]+)$")
    set(_n ${CMAKE_MATCH_1})
    if(_n GREATER 170)
      message(FATAL_ERROR "RC version ${_n} exceeds limit 170")
    endif()
    math(EXPR _stage "340 + ${_n}")
  else()
    message(FATAL_ERROR "Unknown version suffix: ${_suffix} in tag ${_tag_for_parsing}")
  endif()

  # Calculate uint32: Major << 25 | Minor << 17 | Patch << 9 | Stage
  math(EXPR _version_uint32 "${_major} * 33554432 + ${_minor} * 131072 + ${_patch} * 512 + ${_stage}")
else()
  message(FATAL_ERROR "Invalid version format: ${_tag_for_parsing} (Original: ${GIT_TAG})")
endif()

# Check if version has changed by comparing with cached version
get_filename_component(_output_dir "${output_file}" DIRECTORY)
set(_cache_file "${_output_dir}/version.cache")
set(_current_version "${_git_tag}:${_git_revision}")
set(_version_changed TRUE)

if(EXISTS "${_cache_file}")
  file(READ "${_cache_file}" _cached_version)
  string(STRIP "${_cached_version}" _cached_version)
  if("${_cached_version}" STREQUAL "${_current_version}")
    set(_version_changed FALSE)
  endif()
endif()

if(_version_changed)
  # Generate version.h from template
  configure_file("${input_file}" "${output_file}" @ONLY NEWLINE_STYLE LF)

  # Generate version.env for shell scripts
  set(_env_file "${_output_dir}/version.env")
  file(WRITE "${_env_file}" "# Generated by version.cmake - DO NOT EDIT\n")
  file(APPEND "${_env_file}" "GCMZ_VERSION=${_git_tag}\n")
  file(APPEND "${_env_file}" "GCMZ_REVISION=${_git_revision}\n")

  # Update cache file
  file(WRITE "${_cache_file}" "${_current_version}")

  message(STATUS "Generated version.h: ${_git_tag} (${_git_revision})")
  message(STATUS "Generated version.env: ${_env_file}")
else()
  message(STATUS "Version unchanged: ${_git_tag} (${_git_revision})")
endif()
